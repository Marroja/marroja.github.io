<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Diseño a profundidad (ESP-32) - Osciloscopio</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cap_00_intro/index.html">Introducción</a></li><li class="chapter-item expanded "><a href="../cap_01_manual_usuario/index.html"><strong aria-hidden="true">1.</strong> Manual de usuario</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cap_01_manual_usuario/01_alambrado.html"><strong aria-hidden="true">1.1.</strong> Cómo armarlo</a></li><li class="chapter-item expanded "><a href="../cap_01_manual_usuario/02_esp32.html"><strong aria-hidden="true">1.2.</strong> Cómo programarlo</a></li><li class="chapter-item expanded "><a href="../cap_01_manual_usuario/03_aplicacion_java.html"><strong aria-hidden="true">1.3.</strong> Cómo usarlo</a></li></ol></li><li class="chapter-item expanded "><a href="../cap_02_disenno/index.html"><strong aria-hidden="true">2.</strong> Entender el diseño</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cap_02_disenno/00_ideas_disenno.html"><strong aria-hidden="true">2.1.</strong> Diseños descartados</a></li><li class="chapter-item expanded "><a href="../cap_02_disenno/01_alambrado.html"><strong aria-hidden="true">2.2.</strong> Diseño circuito</a></li><li class="chapter-item expanded "><a href="../cap_02_disenno/02_esp32.html"><strong aria-hidden="true">2.3.</strong> Diseño con ESP-32</a></li><li class="chapter-item expanded "><a href="../cap_02_disenno/03_aplicacion_java.html"><strong aria-hidden="true">2.4.</strong> Diseño interfaz usuario</a></li></ol></li><li class="chapter-item expanded "><a href="../cap_03_avanzado/index.html"><strong aria-hidden="true">3.</strong> Usuario avanzado</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cap_03_avanzado/01_alambrado.html"><strong aria-hidden="true">3.1.</strong> Diseño a profundidad (circuito)</a></li><li class="chapter-item expanded "><a href="../cap_03_avanzado/02_programacion.html" class="active"><strong aria-hidden="true">3.2.</strong> Diseño a profundidad (ESP-32)</a></li><li class="chapter-item expanded "><a href="../cap_03_avanzado/03_java.html"><strong aria-hidden="true">3.3.</strong> Diseño a profundidad (aplicación Java)</a></li></ol></li><li class="chapter-item expanded "><a href="../cap_99_extras/index.html"><strong aria-hidden="true">4.</strong> Extras</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cap_99_extras/correo_desfase_dos_ESP.html"><strong aria-hidden="true">4.1.</strong> Correo desfase</a></li><li class="chapter-item expanded "><a href="../cap_99_extras/correo_inversion_condens.html"><strong aria-hidden="true">4.2.</strong> Correo inversión condensadores</a></li><li class="chapter-item expanded "><a href="../cap_99_extras/correo_ion_litio.html"><strong aria-hidden="true">4.3.</strong> Correo baterías ion litio</a></li><li class="chapter-item expanded "><a href="../cap_99_extras/correo_protocolo_sennal.html"><strong aria-hidden="true">4.4.</strong> Correo protocolo señal</a></li><li class="chapter-item expanded "><a href="../cap_99_extras/programa_arduino.html"><strong aria-hidden="true">4.5.</strong> Programa arduino</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Osciloscopio</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="diseño-a-profundidad-esp-32"><a class="header" href="#diseño-a-profundidad-esp-32">Diseño a profundidad (ESP-32)</a></h1>
<p>Para el correcto seguimiento de esta sección del libro se espera un conocimiento moderadamente avanzado del lenguaje de programación C así como un conocimiento básico de señales.</p>
<p>Dada la naturaleza de nuestro proyecto, la tarjeta ESP-32 únicamente funciona como una interfaz entre el mundo real y el mundo digital en el cual queremos representar las gráficas del voltaje de nuestro osciloscopio. </p>
<p>En el capítulo de diseño habíamos mencionado un pseudocódigo a partir del cual nos vamos a basar para programar, ahora sí con código optimizado la tarjeta ESP-32 para obtener la mayor velocidad de muestreo posible así como el comportamiento más homogéneo a lo largo del tiempo que podamos conseguir.</p>
<p>Comencemos con el pseudocódigo original, convirtámoslo en código de Arduino y comencemos a optimizar:</p>
<pre><code>int lectura_ADC_A
int lectura_ADC_B
int pin_ADC_A
int pin_ADC_B

int resta_ADC_AB

inicializa(){

    //De este valor dependerá la velocidad de operación de la ESP32
    configurar_reloj_ESP32                              
    
    //De este valor dependerá nuestra velocidad de envío
    configurar_tasa_baudios_monitor_serial(máximo_valor_estable)    
    
    //De este valor dependerá nuestra calidad de lectura
    configurar_resolución_ADC(máximo_valor_estable)     

}

ciclo(){

    //Leemos los valores de las terminal positiva (A) y la terminal negativa (B) 
    lectura_ADC_A = leer(pin_ADC_A)
    lectura_ADC_B = leer(pin_ADC_B)

    //Al valor de la terminal positiva restarle el valor de la terminal negativa
    resta_ADC_AB = lectura_ADC_A - lectura_ADC_B

    //Mandamos el valor a la computadora
    mandar_serial(resta_ADC_AB)
}

</code></pre>
<p>Convirtiéndolo en código arduino podemos hacer una traducción casi palabra por palabra:</p>
<pre><code class="language-c">//El número de pin en que esperaremos leer los valores de voltaje
#define pin_ADC_A 4
#define pin_ADC_B 6

//Variables para guardar la lectura 0-&gt;4095
int lectura_ADC_A = 0;
int lectura_ADC_B = 0;

int resta_ADC_A_B = 0;

void setup() {

  //Configuramos los ADC a su máxima resolución
  //Por defecto es de 12 bits por lo que podemos comentar casi siempre
  //analogReadResolution(12);

  //Configuramos la velocidad de reloj a la máxima posible
  //Generalmente esta velocidad está predeterminada a 240, comentamos
  //setCpuFrequencyMhz(240); 

  //Comenzamos el monitor serial a la máxima velocidad estable
  Serial.begin(921600);
 
}

void loop() {

  //Leemos el valor de voltaje presente en los pines A y B
  lectura_ADC_A = analogRead(pin_ADC_A);
  lectura_ADC_B = analogRead(pin_ADC_B);

  //Lectura A - Lectura B
  resta_ADC_A_B = lectura_ADC_A - lectura_ADC_B;

  Serial.println(resta_ADC_A_B);
}

</code></pre>
<p>Ya que está explícito el código, limpiemos un poco. Confie en mi, esto se va a saturar pronto:</p>
<pre><code class="language-c">#define pin_ADC_A 4
#define pin_ADC_B 6

int lectura_ADC_A = 0;
int lectura_ADC_B = 0;

int resta_ADC_A_B = 0;

void setup() {
  Serial.begin(921600);
}

void loop() {

  lectura_ADC_A = analogRead(pin_ADC_A);
  lectura_ADC_B = analogRead(pin_ADC_B);

  resta_ADC_A_B = lectura_ADC_A - lectura_ADC_B;

  Serial.println(resta_ADC_A_B);
}
</code></pre>
<p>Hay que utilizar la <a href="https://dl.espressif.com/dl/package_esp32_index.json">biblioteca</a> oficial de Espressif para poder utilizar el IDE de Arduino y subir el código.</p>
<p>[Aquí] el pequeño manual de cómo instalarlo.</p>
<p>Ya preparado esto y subiendo el código a la tarjeta, si hacemos pruebas con nuestro osciloscopio ya armado (tal y como lo armamos en la fase de manual de usuario) podemos abrir la ventana del monitor serial y visualizar los valores desde el propio IDE de Arduino.</p>
<p>Aquí es donde surge la importancia de las herramientas que habíamos propuesto en la fase de diseño:</p>
<p>Windows y Linux <a href="https://www.der-hammer.info/pages/terminal.html">HTerm</a></p>
<p>Para Mac <a href="https://freeware.the-meiers.org/">CoolTerm</a></p>
<p>Si usamos el IDE de Arduino obtendremos más o menos el siguiente comportamiento:</p>
<p align="center">
  <img src="../../capturas/3_avanzado/programa_arduino/captura01.png?raw=true" />
</p>
<p>Pinta bien, si además cambiamos, en vez del monitor serial, usamos el llamado &quot;Serial Plotter&quot; podemos visualizar rápidamente los valores obtenidos desde el EPS-32 en una gráfica.</p>
<p align="center">
  <img src="../../capturas/3_avanzado/programa_arduino/captura02.png?raw=true" />
</p>
<p>Ahora, le pediré que confíe en mi cuando le digo, el código está mal y es muy lento. Las pruebas realizadas fueron extensas por lo que las colocaré en un documento a parte porque escapan de la fase de diseño y son más bien cuestión de la fase de pruebas. </p>
<p><a href="DocuentoPruebasESP-32">Pruebas</a></p>
<p>Para no entrar en demasiado detalle, hay una serie de problemas:</p>
<ul>
<li>El código es muy lento por la conversión que realiza la ESP-32 del valor leído del ADC.</li>
</ul>
<ol>
<li>Se lee el valor del ADC en binario</li>
<li>Se convierte el número a decimal</li>
<li>Se imprime el número como caracters ASCII en el monitor serial</li>
</ol>
<ul>
<li>Esto supone una conversión adicional de número decimal a número de caracter ASCII lo que implica enviar dos bytes de datos ¡POR CADA CIFRA DE NUESTRO NÚMERO!</li>
</ul>
<ul>
<li>Ese último punto revela que nuestro código además de ser lento es inconsistente, esto porque los números leídos de una sola cifra (0-&gt;9) se imprimirán en un solo caracter lo que significa dos bytes, los números de dos cifras (-9 -&gt; 99) se imprimirán como dos caracteres, lo que significan cuatro bytes. ¡Ni siquiera podemos obtener un comportamiento consistente entre números positivos y negativos. Comparando con el número -4095 (pensando que el voltaje en B es de 4095 y el voltaje en A es de 0) tendríamos que enviar cinco caracteres de la ESP-32 hacia la computadora; en comparación con los valores de un solo caracter (0-&gt;9) estaríamos enviando cinco veces más información, haciendo de este protocolo terriblemente ineficiente. </li>
</ul>
<h2 id="nuevo-protocolo-de-cifrado"><a class="header" href="#nuevo-protocolo-de-cifrado">Nuevo protocolo de cifrado</a></h2>
<p>Para arreglar este problema, es necesario proponer un nuevo protocolo de cifrado de nuestros números enteros (-4095 -&gt; 4095) de manera que quepan todos en un tamaño constante de bytes para poder reinterpretarlos en la computadora (en el programa de Java).</p>
<p>Hay múltiples posibilidades para lograr esto, sin embargo, aprovechando que el protocolo serial siempre funciona con el envío de bytes, podemos inmediatamente pensar que dos bytes por número es un tamaño suficiente e incluso sobrante. </p>
<p>Pensemos en el valor binario de 4095 (1111_1111_1111) que es un número de doce bits. Ya que estamos intentando meterlo en dos bytes, es muy claro que en efecto podemos enviar este valor:</p>
<pre><code>16 bits 0000_0000 0000_0000
4095    0000_1111 1111_1111
</code></pre>
<p>Y tendremos una holgura de 4 bits para enviar información adicional que pueda resultar útil.</p>
<p>Entre la información importante que podríamos querer enviar se encuentra si nuestro número leído es positivo o negativo. Después de todo, estamos trabajando con los valores de dos ADC (terminal positiva y terminal negativa) y estamos realizando una resta de valores de 12 bits. (0 -&gt; 4095) para el positivo (A) y (-0-&gt;-4095) para el negativo (B). Esto quiere decir que nuestro rango de posibles valores es en realidad -4095 a 4095, dándonos una extraña resolución de 13 bits a pesar de que nuestro ADC sea de 12 bits.</p>
<p>Esto quiere decir que tendríamos que agregar un bit para enviar el signo:</p>
<pre><code>16 bits 0000_0000 0000_0000
-4095   000s_1111 1111_1111
</code></pre>
<p>El siguiente paso se define únicamente por practicidad de la lectura desde el programa de Java. Cuando empezamos a leer el flujo de valores, únicamente empezaremos a leer paquetes de bytes, no sabremos qué número es el inicio y cuál es el fin del número que se está enviando. Podríamos enviar un tercer byte lleno de unos a partir del cual podríamos determinar el fin del número enviado anterior, pero queda claro que aún tenemos tres bits con los cuales podemos enviar esa información.</p>
<p>Podemos definir en nuestro protocolo que si un número inicia con cero será el inicio de un paquete de dos bytes y si inicia con cero será el final del paquete de dos bytes. Por ejemplo, si observáramos lo siguiente:</p>
<p>Sin embargo, dado que nuestro byte menos significativo puede estar lleno de unos, habrá que definir que los dos primeros bits siempre estén vacíos y nosotros los podamos manipular a voluntad para enviar los bits que signifiquen &quot;inicio de número&quot; &quot;fin de número&quot; así como el bit de &quot;número negativo&quot;.</p>
<pre><code>0010_1110   //fin de número (lo descartamos)
1001_1011   //inicio de número
0011_1100   //fin de número
1001_1001   //inicio de número
...
</code></pre>
<p>Entonces, si el bit con la letra &quot;i&quot; significa &quot;inicio&quot;, &quot;f&quot; significa &quot;fin&quot; y &quot;s&quot; es de &quot;signo&quot; podríamos así fácilmente interpretar los números a partir de los paquetes señalados en ##_####.</p>
<pre><code>is##_####
fs##_####
is##_####
fs##_####
...
</code></pre>
<p>Si definimos que el bit de inicio &quot;i&quot; es 1, el bit de fin &quot;f&quot; es 0, el bit de signo negativo &quot;s&quot; es 1 y el bit de signo positivo &quot;s&quot; es 0, obtendríamos una representación de este estilo:</p>
<pre><code>3094 -&gt; en binario 1100_0001_0110
Visto en paquetes de 6 bits
3094 -&gt; 110000_010110
Lo partimos a la mitad y ponemos los bytes más significativos en el byte de inicio.
(inicio y positivo) 10_110000
enviamos el primer byte
(final y positivo ) 00_010110
enviamos el segundo byte
</code></pre>
<p>Por ejemplo, si las lecturas en el programa de Java fueran:</p>
<pre><code>0001_0110
1011_0000
0001_0110

Podemos descartar el primer byte ya que es un final y no sabemos con qué número inició.
Reordenando el segundo número para darle facilidad visual:
1011_0000 0001_0110
10_110000 00_010110

El primer bit de ambos bytes lo podemos descartar ya que sabemos qué orden tiene el número
0_11000 0_010110

Si el número de inicio es 1 el número será negativo. Si es 0 será positivo.

+ 11000_010110

Convertimos a decimal y aplicamos el binario:

+ (3094) = 3094
</code></pre>
<p>¡Funciona!</p>
<p>Ya con esta información, en el programa de Java podremos interpretar cada número con únicamente dos bytes por número. ¡Mucho mejor que el protocolo inicial de cifrado!</p>
<p>Es verdad que tendremos una redundancia con el signo, como no tenemos un uso especial para ese bit y únicamente simplificará el código del cifrado no debemos preocuparnos demasiado por él. </p>
<p>Entonces, ¿Cómo quedaría el cifrado en código?</p>
<p>Esta parte ya no es de diseño sino de ingeniería de código. Dada la naturaleza de nuestro algoritmo (en el que vamos a jugar mucho con bits a nivel bajo) es posible que sea un poco difícil de entender qué está pasando, sin embargo, ya con el conocimiento de qué queremos hacer podemos ir paso a paso. </p>
<p>Recordemos que hay que codificar un número binario de dos bytes a un número en nuestra codificación.</p>
<p>Vamos a tener que hacer uso de una serie de mañanas de C ya que no tenemos la posibilidad de agregar código ensamblador con el cual hacer estas manipulaciones de bytes. </p>
<p>Comencemos con un ejemplo, el ESP-32 lee el valor en A de 223 y el valor en B de 3359:</p>
<p>Tenemos que conocer el valor de la resta (el cual será negativa en este caso)</p>
<pre><code>    223 - 3359 = -3136
</code></pre>
<p>Para aquellos con buen ojo se habrán dado cuenta de un detalle que no hemos tocado. El número negativo se representará como un número en su complemento a dos. Yo sé que puede parecer un problema pero no lo es. Es por esto que es tan importante mandar el signo del número desde la ESP-32. Vamos a tratar en el código de Java este tema en concreto.</p>
<p>La representación del número -3136 en binario (aunque parezca raro, justo por el complemento a dos) es en un número dos:</p>
<pre><code>1111_0011 1100_0000
</code></pre>
<p>El número que nos interesa es el de los primeros 12 bits y sabemos que el número es negativo. Sabemos que el número será negativo si y solo si los primeros cuatro bits son todos 1. Esto se debe al llamado desbordamiento. Lo que vamos a hacer va a ser aprovechar este desbordamiento para encontrar y enviar el signo del número que vamos a enviar de la ESP-32 a la computadora.</p>
<p>Entonces, ya que si vemos el número &quot;desbordado&quot; en 16 bits mientras que el número es uno de 12 bits, sabremos que el número en cuestión es un número negativo.</p>
<pre><code class="language-c">if (x &gt; 4096){
    //El número es negativo
    //Por la cadena de 1111
    //1111_xxxx_xxxx_xxxx
}
</code></pre>
<p>Sin embargo, ni siquiera es necesario es hacer la condicional, podemos diréctamente poner ese 1 como el valor que nos interesa en el número de 16 bits ya cifrado.</p>
<p>Entonces:</p>
<ol>
<li>Usaremos dos bytes, vacíos, a esos dos bytes les pondremos los doce bits marcados con xxxx_xxxx_xxxx. </li>
<li>Agregaremos el signo, que como 1 es nuestro negativo, podemos escribirlo diréctamente de los 1111 desde el desbordamiento.</li>
<li>Limpiamos la cola de 1111 del primer byte y agregamos los 6 bits al byte que corresponden</li>
<li>Etiquetamos con un 1 el primer bit para el primer byte</li>
<li>Etiquetamos con un 0 el primer bit del segundo byte (cosa que podemos no hacer porque el número inicia siendo puros ceros).</li>
<li>Imprimimos como bytes (NO COMO TEXTO) de la ESP-32 a la computadora </li>
</ol>
<p>Paso a pasito, para no perdernos en la manipulación de bits:</p>
<pre><code class="language-c">//El número de pin en que esperaremos leer los valores de voltaje
#define pin_ADC_A 4
#define pin_ADC_B 15

//Usaremos short que es una estructura de 16 bits
short lectura_ADC_A = 0b0;
short lectura_ADC_B = 0b0;

short resta_ADC = 0b0;

//Estas serán las variables que enviaremos por medio del serial
byte num_codificado_primero = 0b0;
byte num_codificado_segundo = 0b0;

void setup() {
  Serial.begin(921600);
}

void loop() {

  //Inicializamos los valores de nuestros bytes
  //Podemos poner el etiquetado del primero byte de una vez
  num_codificado_primero = 0b10000000;
  num_codificado_segundo = 0b00000000;

  lectura_ADC_A = analogRead(pin_ADC_A);
  lectura_ADC_B = analogRead(pin_ADC_B);  
  resta_ADC = lectura_ADC_A - lectura_ADC_B;

  //Recordemos que resta_ADC es un número de 16 bits
  //Los números codificados son de un solo byte
  //Por esto tenemos que recorrerlo un byte
  //Para tener acceso a la cola de 1111
  //Aquí estamos sumando el segundo 1, 0100
  //Por eso aplicamos una máscara lógica &amp;&amp;
  num_codificado_primero += ((resta_ADC &gt;&gt; 8) &amp;&amp; 0b01000000);
  num_codificado_segundo += ((resta_ADC &gt;&gt; 8) &amp;&amp; 0b01000000);

  //Aplicando otra máscara lógica sumamos los 6 bits
  //Tenemos que recorrer 6 lugares para sumar al primer byte
  //  ssss_xxxx_xxxx_xxxx  -&gt;   ssss_xxxx_xxxx_xxxx
  //            isxx_xxxx  -&gt;     is_xxxx_xx
  num_codificado_primero += ((resta_ADC &gt;&gt; 6) &amp;&amp; 0b00111111);
  //Tenemos que recorrer 0 lugares para sumar al primer byte
  //  ssss_xxxx_xxxx_xxxx  -&gt;   ssss_xxxx_xxyy_yyyy
  //            isxx_xxxx  -&gt;             isxx_xxxx
  num_codificado_segundo += (resta_ADC &amp;&amp; 0b00111111);

  Serial.print(&quot;Resta:&quot;);
  Serial.println(resta_ADC);
  Serial.print(&quot;1ero:&quot;);
  Serial.println(num_codificado_primero);
  Serial.print(&quot;2ndo&quot;);
  Serial.println(num_codificado_segundo);
}

</code></pre>
<p>Solo para revisar rápidamente en el monitor serial si se está enviando correctamente nuestro número, podemos usar Serial.print() para revisar los valores enviados. En todos las implementaciones ya funcionales usaremos Serial.write() además ya no imprimiremos las banderas de &quot;Resta, 1ero, 2nd&quot;. </p>
<p>Entonces, ¿qué obtenemos?</p>
<p align="center">
  <img src="../../capturas/3_avanzado/programa_arduino/captura03.png?raw=true" />
</p>
<p>Si conectamos ambas terminales (positiva y negativa) al mismo voltaje de tierra, vamos a obtener un resultado más o menos como el mostrado. Interpretémoslo:</p>
<p>El primer valor que estamos imprimiendo es la resta de los valores del ADC_A - ADC_B, recordemos que estos son números entre 0 -&gt; 4095 por lo que valores como -31 son en realidad bastante cercanos al cero. Esto es congruente con la lectura que estamos haciendo de la tierra, esperaríamos un valor leído de 0, sin embargo, por ruido generado por el efecto de antena de los cables así como errores en los resistores con los que estamos trabajando también traerá un poco de desviación. (Además recordemos que estamos trabajando con un circuito diseñado con un 1% de error).</p>
<p>Los segundos valores son &quot;1ero&quot; que es el valor del primer byte, en el cual vamos 255 para todos los mostrados en la captura. El tercer valor impreso es &quot;2ndo&quot; que es el segundo byte de nuestro paquete, este oscila entre 97 y 91 en la captura, pero para ser congruentes con la lectura de la &quot;resta&quot; vamos a usar la primera lectura:</p>
<pre><code>Resta: -38
1ero : 255
2ndo : 90
</code></pre>
<p>Esta información es suficiente como para saber si nuestra codificación fue correcta, veamos. Tendremos que hacer la traducción de -38 a dos bytes 255_90 o esos dos byte a -38. Considero que es más fácil hacerlo de los dos bytes a -38, en especial por el hecho de que el número es negativo, y eso es algo que tenemos que explicar rápidamente (como decíamos más arriba con el complemento a 2).</p>
<pre><code>255 = 1111_1111 
90  = 0101_1010
</code></pre>
<p>El orden de los dos bytes es correcto (como vemos por el 1 y 0 en los primeros bits)
También sabemos que el número que estamos leyendo es negativo (como vemos en el segundo bit 1 de ambos bytes)</p>
<pre><code>1ero = 11_1111
2ndo = 01_1010

Juntos = 11_1111_01_1010 -&gt; 1111_1101_1010
</code></pre>
<p>Este número es 4058 en binario. Sin embargo, hay que recordar que el número es negativo, esto significa que en realidad estamos trabjando con el complemento a 2 del número en una representación de 12 bits.</p>
<p>Si sacamos el complemento a 2 de este número obtendremos el valor real del número pero tendremos que considerarlo negativo:</p>
<pre><code>1111_1101_1010 -&gt; 0000_0010_0101 + 1 -&gt; 0000_0010_0110 = 38
Con su signo menos: -38
</code></pre>
<p>Así que, en efecto, hemos enviado correctamente el mensaje.
Ya que sabemos que nuestro código es funcional, podemos cambiar el Serial.print() por Serial.write() y obviar los comentarios de &quot;Resta, 1ero, 2ndo&quot;:</p>
<p>Código final</p>
<pre><code class="language-c">//El número de pin en que esperaremos leer los valores de voltaje
#define pin_ADC_A 4
#define pin_ADC_B 15

//Usaremos short que es una estructura de 16 bits
short lectura_ADC_A = 0b0;
short lectura_ADC_B = 0b0;

short resta_ADC = 0b0;

//Estas serán las variables que enviaremos por medio del serial
byte num_codificado_primero = 0b0;
byte num_codificado_segundo = 0b0;

void setup() {
  Serial.begin(921600);
}

void loop() {

  //Inicializamos los valores de nuestros bytes
  //Podemos poner el etiquetado del primero byte de una vez
  num_codificado_primero = 0b10000000;
  num_codificado_segundo = 0b00000000;

  lectura_ADC_A = analogRead(pin_ADC_A);
  lectura_ADC_B = analogRead(pin_ADC_B);  
  resta_ADC = lectura_ADC_A - lectura_ADC_B;

  //Recordemos que resta_ADC es un número de 16 bits
  //Los números codificados son de un solo byte
  //Por esto tenemos que recorrerlo un byte
  //Para tener acceso a la cola de 1111
  //Aquí estamos sumando el segundo 1, 0100
  //Por eso aplicamos una máscara lógica &amp;&amp;
  num_codificado_primero += ((resta_ADC &gt;&gt; 8) &amp;&amp; 0b01000000);
  num_codificado_segundo += ((resta_ADC &gt;&gt; 8) &amp;&amp; 0b01000000);

  //Aplicando otra máscara lógica sumamos los 6 bits
  //Tenemos que recorrer 6 lugares para sumar al primer byte
  //  ssss_xxxx_xxxx_xxxx  -&gt;   ssss_xxxx_xxxx_xxxx
  //            isxx_xxxx  -&gt;     is_xxxx_xx
  num_codificado_primero += ((resta_ADC &gt;&gt; 6) &amp;&amp; 0b00111111);
  //Tenemos que recorrer 0 lugares para sumar al primer byte
  //  ssss_xxxx_xxxx_xxxx  -&gt;   ssss_xxxx_xxyy_yyyy
  //            isxx_xxxx  -&gt;             isxx_xxxx
  num_codificado_segundo += (resta_ADC &amp;&amp; 0b00111111);

/*
  Serial.print(&quot;Resta:&quot;);
  Serial.println(resta_ADC);
  Serial.print(&quot;1ero:&quot;);
  Serial.println(num_codificado_primero);
  Serial.print(&quot;2ndo:&quot;);
  Serial.println(num_codificado_segundo);
*/
  Serial.write(num_codificado_primero);
  Serial.write(num_codificado_segundo);

</code></pre>
<p>Si intentamos leer los valores mostrados con el código usando Serial.write() no podremos ver ningún valor con sentido en la terminal de Arduino, sin embargo, en CoolTerm o en HTerm sí podremos ver los valores si usamos el modo de visualización en hexadecimal o en binario. </p>
<p>Veremos algo del siguiente tipo:</p>
<p align="center">
  <img src="../../capturas/3_avanzado/programa_arduino/captura04.png?raw=true" />
</p>
<p>Aquí, tal como en el análisis que hicimos previamente, podemos ver que hay muchos bytes del tipo &quot;FF&quot; o sea 255 en decimal, que son casi el mismo byte que interpretamos previamente. Esta aplicación está hecha para visualizar el valor de los bytes y no interpretarlos en el cifrado que nosotros diseñamos. Es por eso que el paso subsecuente es interpretar estos valores a una alta velocidad y graficarlos.</p>
<p>Para esto, exploraremos las posibilidades en la siguiente sección de esta capítulo.</p>
<h2 id="diseños-subsecuentes"><a class="header" href="#diseños-subsecuentes">Diseños subsecuentes</a></h2>
<p>Si usted lector se siente suficientemente aventurado como para realizarle cambios a este protocolo de comunicación, si por casualidad contara con una tarjeta con una resolución más alta en su ADC y quisiera aprovecharla, aquí dejaré una seried e recomendaciones, las cuales espero le sirvan de algo. </p>
<p>A manera de recapitulación, comenzamos con el código más sencillo posible (el que planteamos en el capítulo de diseño) y lo usamos como plantilla para generar este código nuevo. Es una buena idea comenzar con algo ineficiente y malo como plantilla para optimizar y optimizar hasta llegar a un resultado que uno considere suficientemente bueno. </p>
<p>Dado que estamos trabajando con el análisis de señales le recomiendo enormemente que no le tema al trabajo con los valores binarios en los bytes. C no es el lenguaje más amable al momento de permitirnos estas manipulaciones pero es suficientemente bueno y claro si uno mantiene notas y comentarios como los fuimos haciendo durante nuestro desarrollo.</p>
<p>En caso de tener una tarjeta de mayor resolución de ADC (pensemos que fuera de 16-bits) lo más probable es que tenga que agregar un tercer byte como bandera de inicio/fin de paquetes de datos. La realidad es que es de suma importancia escribir un protocolo de comunicación claro al momento de leerlo. Como se dio cuenta, al momento de leerlo hay ciertos datos que inmediatamente se pueden descartar porque su significado se puede interpretar solo con verlo. </p>
<p>Evite el uso de condicionales y codificaciones externas, después de todo, nadie conoce mejor la implementación del dispositovo que el propio diseñador y el diseñador tiene que estar dispuesto a optimizar su trabajo hasta las últimas consecuencias, no importa si tiene que descartar la tecnología más usada para encontrar algo que se acople mejor a sus necesidades.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../cap_03_avanzado/01_alambrado.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../cap_03_avanzado/03_java.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../cap_03_avanzado/01_alambrado.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../cap_03_avanzado/03_java.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
